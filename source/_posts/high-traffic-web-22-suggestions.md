title: 建设高流量网站的22个建议
date: 2014-02-02 17:55:58
tags: web
---

Ashwanth Fernando在13/12/16发表于High Scalability的这篇文章对于正在考虑建立高流量网站的创业者颇有借鉴意义。兹摘译如下。

读前注意：
1. 仅供参考。
2. 在不同的真实场景中可能未必适用。

### 考虑多个数据中心

容灾问题不容忽视。为了让你的业务避免受到自然灾害或电力故障的影响，考虑多机房部署很重要。

采用active-active配置，而不是active-passive配置，虽然前者花费更多，但后者可能会导致passive部分的数据和active部分不一致。

### 在同一个数据中心里分散部署

确保你的运维团队把软件部署到多个连接不同电源供应的rack上。rack的电源开关可能会失效从而导致rack停电。

### 考虑运行一个私有云

在IaaS软件如OpenStack还不够成熟的今天，运维一个自有的私有云会需要投入一个巨大的运维团队，但是，私有云还是有很多优点的。

首先，你可以比采用AWS或Rackspace有更多的定制化部署。比如，你可以把软件部署在离控制软件如Zookeeper更近的rack上。

第二，它可以让你提供裸机(bare metal provisioning)。比如，Oracle在裸机上的运行速度就比在虚拟化环境下快得多。

### 考虑采用PaaS

时至今日，一大群人坐在那里发布软件的时代一去不复返了。今天的组织希望更高度的敏捷性，以及更快速地把产品推向市场。采用自有PaaS (加上适度的权限管理)会让你的开发人员更快速地完成部署。这让产品的新功能发布更快，并且你会发现开发者也非常开心。是的，让开发者使用自助工具去部署和维护他们的软件会极大增强他们的开心指数。今天，越来越多的开发者，甚至不会加入一家没有自动化软件部署工具的公司。

越少官僚化和形式化的流程越好。

### 数据库只用来按主键查找记录

当RAC里没有用太多数据库特性的时候，Oracle在高流量压力下能有最佳表现。

尽可能少地使用以下特性：referential integrity, tiggers, materialized views, views, stored procedures以及其他Oracle特性。

把这些东西都搬到应用层：任一个ORM都会保证引用一致性。数据访问层自身就能实现触发器功能。存储过程可以完全被移到应用层。

只用数据库存储数据，不要用它做任何其他事情。

如果需要基于主键以外的字段进行查找记录，使用索引器例如Lucene建立索引，创建一个搜索服务以能够搜索其他字段并返回记录的主键。这个主键稍后可以用来取得记录。

### 将数据库分片(sharding)

在schema很多的情况下Oracle的扩展性就会受到极大局限。因此，最好按照你的schema的功能分片(比如，订单，产品目录，促销，客户，等等)，同时，为高密度表创建key分片。

对key分片使用一致性哈希，这样，当增加一个RAC时，你就不需要遍历所有RAC的key来找出来哪些key需要迁移到key分片。

### 如果使用Oracle，考虑使用Data Guard或者Golden Gate

【青焱注：略】

### 考虑在数据库前面增加一个数据访问层

假设你的Oracle RAC能够接受500个并发连接。现在设想你有25个jBoss实例和你的Oracle RAC通信。每一个jBoss实例的数据库连接池的维持连接数配置为最低10个最高50个。

当你的jBoss集群启动后，Oracle就会收到 25 x 10 也就是 250 个并发连接。一切工作都很完美。但是，当访问高峰期来临时，Oracle就会开始拒绝连接了。

因此，建议的解决方案就是增加一个多工层(multiplexer layer)来给应用服务器连接增加多工能力。这可以是一个简单的运行在集群上的netty应用。每个netty应用只开启25个并发连接到Oracle，但是可以接受尽可能多的连接请求。这样，它就可以采用事件循环的方法来把进入的连接多工接入Oracle但不超出Oracle的25个连接数限制。它可以采用Oracle JDBC驱动来和Oracle对话。

在jBoss应用层的实现就可以简单采用JDBC和netty多工层对话，只需要把它当作一个数据库即可。

### 不要让事务操作横跨多个机房

时至今日，这一常识可能已经像日常小菜一样稀松平常了，但依旧是非常有用的建议。

对于Oracle，不要使用XA适配器在两个不同机房的Oracle RAC之间进行数据库事务操作。这会让你的应用线程阻塞相当长的一段时间，直到两段式提交完成。然后你的应用服务以及所有上游同步服务全部阻塞，应用线程数量随着流量压力的增加不断增长，最终导致你的应用服务彻底down掉。

### 考虑使用分布式缓存框架

这里，Memcached, Couchbase是常规考虑对象。把相对不常变化的数据卸载到一个集中的缓存集群中去吧，真的没必要在每一个JVM里存储一份拷贝。不过，设置一小块JVM堆内存用来作为分布式缓存的MRU缓存是个好主意。这样可以极大减少到缓存集群的网络调用次数。

大多数的分布式缓存支持在JVM里设置一个本地缓存来存储最近最常用数据对象。

同时，JVM的GC冰冻时间也可以被最小化，因为在标记阶段(marking phase)它需要遍历的对象数量更少了。

考虑由PaaS自动或者你的运维团来手动用热身程序向应用服务器的url发起HTTP来给分布式缓存热身。在晚上或其他用户流量压力比较低的时间来做这个事情。

### 考虑把你的web应用分解成服务

如果你在负责一个50万行代码的web应用，还在把它们打成一个包部署，那么抓紧动手把它们分解成服务吧。服务按照功能划分，然后可以分配给不同的部门或团队维护。

把一个单一的web应用分解成服务会带来非常多的好处：

1. 调试问题更加方便。
2. 扩展以及调优独立的子系统变得更加简单。
3. 当子系统拆分并更加容易理解，在生产环境下观察运行情况也变得更加容易。
4. 增加新功能现在会更加快捷。

### 避免会话粘性

会话粘性(session stickiness)绝对是魔鬼。它可以保证你在高压力下不能扩展。

你的客户应该能够向任意一个应用服务器发起请求然后得到结果。要做到这一点就要让服务无状态，也就是成为所谓的Restful服务。维持状态的id携带在每次会话请求中，而表示客户会话的数据则存储在数据库或分布式缓存中以供多次请求反复使用。

使用一个包装在每一个服务上的servlet过滤器从每次请求中取出id、请求分布式缓存、填充会话数据以供后续处理逻辑使用。这样，数据中心的每一台服务器都可以响应客户端的请求，因为状态集中存储在了memcached里。

避免会话粘性还能够让你能够滚动重启你的应用服务集群，从而实现100%的服务在线时间。

### 在反向代理处终止SSL

反向代理用来处理SSL握手(通常要耗费8次来回请求)并保持住下层TCP连接。

在反向代理上显式设置一个TCP连接保持时间。Nginx以及其他很多http服务器都支持这个功能，并能让这些TCP连接被重用很多次。TCP握手的耗费只有3次网络请求，你能够避免很多无谓的网络请求消耗。

从反向代理到应用服务器通常是原生http协议。所以把上游连接的TCP保持连接也开启吧。

### 在全局负载均衡器(GSLB)上使用会话粘性

对于跨数据中心的负载均衡，建议使用会话粘性。这是因为数据库——Oracle或者Cassandra在跨数据中心同步时只能采用最终一致(eventual consistency)技术。

【青焱注：最终一致意味着数据同步是有延迟的。GSLB最好把同一用户最近的连续请求都路由给同一个服务方，以避免在用户端出现数据不一致的情况。】

一定要使用GSLB。你的CDN多数情况下会有基于本地性的GSLB方案来做数据中心负载均衡。

### 减少首页的CNAME查询

努力减少首页的CNAME查询数量。一些流行的站点仅仅首页就有10个甚至更多的CNAME查询。尽管你的用户的DNS查询可能会从ISP的递归缓存中得到应答，但这仍然不是一个好方案。

www.amazon.com就没有CNAME查询。

```
;; QUESTION SECTION:
;www.amazon.com.			IN	A

;; ANSWER SECTION:
www.amazon.com.		120	IN	A	205.251.242.54
```

### 拥抱所有的reactor模式

Reactor模式已经被实践证明是高流量软件系统的不二之选。一小撮框架被创建并实现了reactor模式，试举几例：

* 反向代理：Nginx
* 应用服务器：node.js
* 并行处理：Scala的actor model

除非你的业务逻辑是高度计算密集型的(CPU bound)，否则请考虑使用reactor模式或事件循环(event loop)的软件。

如果不能采用这些软件，那么就考虑采用reactive编程模式框架比如RxJava。

### 设置调用超时

在一系列服务调用(a call graph of service calls)中，为调用设置超时，并且自顶向下采用逐步减小的超时时间。

下一步，在每次调用这一系列服务的时候，创建一个UUID，并且在分布式缓存中设置一个标志：

UUID: true

如果系列服务中的任何一个超时了，就把这个UUID的标志设为false。

为所有的服务实现一个servlet过滤器，检查这个标志并当且仅当标志为true的时候才继续进行。

如果标志是false，说明服务出现了问题，此时直接返回空响应即可。

这一技巧可以在高流量压力下减轻那些不必要的请求压力。

### 实现GC侦查协议

技巧：让所有的服务都通过netty暴露一个TCP端口并返回一个空字符串。当调用服务之前，请求这个TCP端口并且设置2ms-5ms的超时时间。如果请求超时，那么就说明java进程正在进行“世界世界停止吧”的垃圾回收工作。

让客户端立刻切换到另外一个服务实例并尝试同样的流程。如果请求成功，那么就请求这个实例上的服务。

注意：这一协议的实现需要客户端IP地址配置(也就是客户端负载均衡)。

### 让业务逻辑和I/O访问越多异步越好

让业务逻辑异步化可以保护你的应用在突发高压力时免于创建过多线程。

把时间推送到一个负载均衡的队列集群中去，然后让业务逻辑处理进程从订阅队列里的事件并进行处理。避免把处理代码全部放到http请求/响应线程中。

### 偏向于采用最终一致数据库

特别是当你运行跨数据中心的应用时。除非你的案例是事务型的(比如下订单)，请偏向于采用最终一致型数据库比如Cassandra。尽可能少采用ACID数据库。

### 务必采用CDN供应静态内容

使用CDN供应静态内容——javascript, 图片, css等。CDN能够非常高效地复制静态内容到靠近客户的地方，从而极大缩短了用户请求这些静态内容的物理距离。

【青焱注：考虑和计算一下光速的极限吧。】

### 把javascript打包到一个文件里并压缩

如题。同时也要压缩内嵌的javascript代码。

注意：不要在发布到生产环境之前做这个。你还需要调试呢。

***你有什么样的心得和技巧呢？在下面留言和大家分享吧！***

[原文链接](http://highscalability.com/blog/2013/12/16/22-recommendations-for-building-effective-high-traffic-web-s.html)
